
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>reshapetimeseries documentation</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-03-06"><meta name="DC.source" content="reshapetimeseries_documentation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1><tt>reshapetimeseries</tt> documentation</h1><!--introduction--><p>The <tt>rehspaetimeseries</tt> function reshapes a vector of timeseries data onto a grid, accounting for messiness associated with leap days or unevenly-spaced data.</p><p><a href="CDT_Contents.html">Back to Climate Data Tools Contents</a></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Example</a></li></ul></div><h2 id="1">Syntax</h2><pre>[xg, yr] = reshapetimeseries(t, x)
[xg, yr] = reshapetimeseries(t, x, 'bin', bin)
[xg, yr] = reshapetimeseries(t, x, 'func', func)
[xg, yr] = reshapetimeseries(t, x, 'yrlim', yrlim)
[xg, yr] = reshapetimeseries(t, x, 'pivotdate, [mon day])</pre><h2 id="2">Description</h2><h2 id="3">Example</h2><p>When working with timeseries data, one often wants to analyze or plot things by time of year.  For example, let's look at the sea ice extent example:</p><pre class="codeinput">load <span class="string">seaice_extent</span>;

plot(t, extent_N);
</pre><img vspace="5" hspace="5" src="reshapetimeseries_documentation_01.png" alt=""> <p>We can use &lt;doy_documentation.html <tt>doy</tt>) to put this data on a day-of-year axis rather than datetimes:</p><pre class="codeinput">cla;
plot(doy(t), extent_N);
</pre><img vspace="5" hspace="5" src="reshapetimeseries_documentation_02.png" alt=""> <p>But ugh, that wrapping from one year to the next prevents any quick and easy plotting. And we can calculate statistics across years by using <tt>splitapply</tt> or <tt>accumarray</tt>:</p><pre class="codeinput">[g, tdoy] = findgroups(floor(doy(t)));
iceavg = splitapply(@nanmean, extent_N, g);
</pre><p>But that syntax gets awfully clunky when you want to do more in-depth analysis.  Both of these tasks would be a lot simpler if we could just reshape the data into matrix.  The problem, of course, is those pesky leap days, always leading to uneven numbers of datapoints in different years and throwing off attempts to reshape.  The <tt>reshapetimeseries</tt> function cleans up that messiness:</p><pre class="codeinput">[ice, yr, tmid] = reshapetimeseries(t, extent_N);

plot(tmid, ice, <span class="string">'b'</span>)
hold <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="reshapetimeseries_documentation_03.png" alt=""> <p>By default, it uses date bins, which makes sure to keep calendar dates aligned from one year to the next, and averages Feb 28-29 data in leap years.  Monthly binning can also be achieved by setting the 'bin' input appropriately. (Note that the first year in this dataset started mid-October, which leads to the outlier-like point in the monthly averages).</p><pre class="codeinput">[icem, yr, tmidm] = reshapetimeseries(t, extent_N, <span class="string">'bin'</span>, <span class="string">'month'</span>);

plot(tmidm, icem, <span class="string">'r'</span>)
</pre><img vspace="5" hspace="5" src="reshapetimeseries_documentation_04.png" alt=""> <p>While Jan 1 is usually a good place to place the year-to-year wrap, sometimes your dataset may call for a different placement.  For example, we can place the wrap near the low point of this timeries, in October. In this example, we choose 52 evenly-spaced bins per year, which is approximately a weekly average:</p><pre class="codeinput">[ice, yr, tmid] = reshapetimeseries(t, extent_N, <span class="keyword">...</span>
    <span class="string">'pivotdate'</span>, [9 15], <span class="string">'bin'</span>, 52);

cla
plot(tmid, ice, <span class="string">'b'</span>)
hold <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="reshapetimeseries_documentation_05.png" alt=""> <p>One thing to be aware of with this function is that it will add a NaN placeholder for any bins where no data existed in the original timeseries.  Most of the time this will correspond to larger gaps in your timeseries, e.g. at the beginning or end if the timeseries doesn't start and end on the same calendar day.  However, this can also occur if you choose a binning interval on a finer scale than your original data. For example, in this dataset, the early data is sampled every 2 days.  If we try binning this on a daily basis, we end up with sparse data, staggered every other year:</p><pre class="codeinput">isearly = t &lt; datetime(1988,1,1);
[ice, yr, tmid] = reshapetimeseries(t(isearly), extent_N(isearly));

tlbl = doy(tmid, <span class="string">'decimalyear'</span>)- year(tmid(1));

figure;
imagesc(yr, tlbl, ice);
shading <span class="string">flat</span>;
cmocean(<span class="string">'ice'</span>);
xlabel(<span class="string">'Year'</span>);
ylabel(<span class="string">'Year fraction'</span>);
</pre><img vspace="5" hspace="5" src="reshapetimeseries_documentation_06.png" alt=""> <p>In this case, we'd want to make sure we chose a larger interval when doing any real analysis:</p><pre class="codeinput">[ice, yr, tmid] = reshapetimeseries(t(isearly), extent_N(isearly), <span class="string">'bin'</span>, floor(365/2));

figure;
imagesc(yr, tlbl, ice);
shading <span class="string">flat</span>;
cmocean(<span class="string">'ice'</span>);
xlabel(<span class="string">'Year'</span>);
ylabel(<span class="string">'Year fraction'</span>);
</pre><img vspace="5" hspace="5" src="reshapetimeseries_documentation_07.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% |reshapetimeseries| documentation 
%
% The |rehspaetimeseries| function reshapes a vector of timeseries data
% onto a grid, accounting for messiness associated with leap days or
% unevenly-spaced data.
%
% <CDT_Contents.html Back to Climate Data Tools Contents>
%
%% Syntax
%
%  [xg, yr] = reshapetimeseries(t, x)
%  [xg, yr] = reshapetimeseries(t, x, 'bin', bin)
%  [xg, yr] = reshapetimeseries(t, x, 'func', func)
%  [xg, yr] = reshapetimeseries(t, x, 'yrlim', yrlim)
%  [xg, yr] = reshapetimeseries(t, x, 'pivotdate, [mon day])

%% Description

%% Example
%
% When working with timeseries data, one often wants to analyze or plot
% things by time of year.  For example, let's look at the sea ice extent
% example:

load seaice_extent;

plot(t, extent_N);

%%
% We can use <doy_documentation.html |doy|) to put this data on a
% day-of-year axis rather than datetimes:

cla;
plot(doy(t), extent_N);

%%
% But ugh, that wrapping from one year to the next prevents any quick and
% easy plotting. And we can calculate statistics across years by using
% |splitapply| or |accumarray|: 

[g, tdoy] = findgroups(floor(doy(t)));
iceavg = splitapply(@nanmean, extent_N, g);

%%
% But that syntax gets awfully clunky when you want to do more in-depth
% analysis.  Both of these tasks would be a lot simpler if we could just
% reshape the data into matrix.  The problem, of course, is those pesky
% leap days, always leading to uneven numbers of datapoints in different
% years and throwing off attempts to reshape.  The |reshapetimeseries|
% function cleans up that messiness:

[ice, yr, tmid] = reshapetimeseries(t, extent_N);

plot(tmid, ice, 'b')
hold on

%%
% By default, it uses date bins, which makes sure to keep calendar dates
% aligned from one year to the next, and averages Feb 28-29 data in leap
% years.  Monthly binning can also be achieved by setting the 'bin' input
% appropriately. (Note that the first year in this dataset started
% mid-October, which leads to the outlier-like point in the monthly
% averages).  

[icem, yr, tmidm] = reshapetimeseries(t, extent_N, 'bin', 'month');

plot(tmidm, icem, 'r')

%%
% While Jan 1 is usually a good place to place the year-to-year wrap,
% sometimes your dataset may call for a different placement.  For example,
% we can place the wrap near the low point of this timeries, in October.
% In this example, we choose 52 evenly-spaced bins per year, which is
% approximately a weekly average:

[ice, yr, tmid] = reshapetimeseries(t, extent_N, ...
    'pivotdate', [9 15], 'bin', 52);

cla
plot(tmid, ice, 'b')
hold on


%%
% One thing to be aware of with this function is that it will add a NaN
% placeholder for any bins where no data existed in the original
% timeseries.  Most of the time this will correspond to larger gaps in your
% timeseries, e.g. at the beginning or end if the timeseries doesn't
% start and end on the same calendar day.  However, this can also occur if
% you choose a binning interval on a finer scale than your original data.
% For example, in this dataset, the early data is sampled every 2 days.  If
% we try binning this on a daily basis, we end up with sparse data,
% staggered every other year:

isearly = t < datetime(1988,1,1);
[ice, yr, tmid] = reshapetimeseries(t(isearly), extent_N(isearly));

tlbl = doy(tmid, 'decimalyear')- year(tmid(1));

figure;
imagesc(yr, tlbl, ice);
shading flat;
cmocean('ice');
xlabel('Year');
ylabel('Year fraction');

%%
% In this case, we'd want to make sure we chose a larger interval when
% doing any real analysis:

[ice, yr, tmid] = reshapetimeseries(t(isearly), extent_N(isearly), 'bin', floor(365/2));

figure;
imagesc(yr, tlbl, ice);
shading flat;
cmocean('ice');
xlabel('Year');
ylabel('Year fraction');




##### SOURCE END #####
--></body></html>